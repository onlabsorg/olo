<%  title = "olowiki expression: L < R"  %>
<%  __render__ = import("/bin/markdown")  %>

<% test = import("/bin/test") %>
<% check = test.check %>

<% XLT = {__vs__: (R) -> -100} %>
<% XEQ = {__vs__: (R) -> 0} %>
<% XGT = {__vs__: (R) -> +35} %>
<% XNN = {__vs__: (R) -> "abc"} %>
<% foo1: () -> 1+1 %>
<% foo2: () -> 1+2 %>


### When L is NOTHING
By default `NOTHING` is equal only to itself and less than any other data type.
* Expect `NOTHING < NOTHING` to be `FALSE`  <% test.not(NOTHING<NOTHING) %>
* Expect `NOTHING < number` to be `TRUE`    <% test(NOTHING<10) %>
* Expect `NOTHING < text` to be `TRUE`      <% test(NOTHING<"abc") %>
* Expect `NOTHING < function` to be `TRUE`  <% test(NOTHING<foo1) %>
* Expect `NOTHING < list` to be `TRUE`      <% test(NOTHING<[10,20,30]) %>
* Expect `NOTHING < namespace` to be `TRUE` <% test(NOTHING<{}) %>

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `<` operation is defined by its return value.
* Expect `FALSE` if `R.__vs__(L)` returns a negative number (R < L) <% test.not(NOTHING < XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                <% test.not(NOTHING < XEQ) %>
* Expect `TRUE` if `R.__vs__(L)` returns a positive number (R > L)  <% test(NOTHING < XGT) %>
* Expect `TRUE` if `R.__vs__(L)` doesn't return a number            <% test(NOTHING < XNN) %>


### When L is a number
By default a number is lower than bigger numbers, text, functions, lists and
namespaces.
* Expect `FALSE` when R is `NOTHING`        <% test.not(10<NOTHING) %> 
* Expect `FALSE` if R is the same number    <% test.not(10<10) %> 
* Expect `FALSE` if R is a smaller number   <% test.not(10<5) %> 
* Expect `TRUE` if R is a bigger number     <% test(10<20) %> 
* Expect `TRUE` when R is a string          <% test(10<"abc") %> 
* Expect `TRUE` if R is a function          <% test(10<foo1) %> 
* Expect `TRUE` when R is a list            <% test(10<[10,20,30]) %> 
* Expect `TRUE` when R is a namespace       <% test(10<{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `<` operation is defined by its return value.
* Expect `FALSE` if `R.__vs__(L)` returns a negative number (R < L) <% test.not(10 < XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                <% test.not(10 < XEQ) %>
* Expect `TRUE` if `R.__vs__(L)` returns a positive number (R > L)  <% test(10 < XGT) %>
* Expect `TRUE` if `R.__vs__(L)` doesn't return a number            <% test(10 < XNN) %>


### When L is a string
By default a text is equal only to the same text.
* Expect `FALSE` wher R is `NOTHING`            <% test.not("abc"<NOTHING) %>
* Expect `FALSE` when R is a number             <% test.not("abc"<10) %> 
* Expect `FALSE` when R is the same string       <% test.not("abc"<"abc") %> 
* Expect `FALSE` when R is a string that comes before L alphabetically   <% test.not("abc"<"aaa") %> 
* Expect `TRUE` when R is a string that comes after L alphabetically   <% test("abc"<"def") %> 
* Expect `TRUE` if R is a function             <% test("abc"<foo1) %> 
* Expect `TRUE` when R is a list               <% test("abc"<[10,20,30]) %> 
* Expect `TRUE` when R is a namespace          <% test("abc"<{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `<` operation is defined by its return value.
* Expect `FALSE` if `R.__vs__(L)` returns a negative number (R < L) <% test.not("abc" < XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                <% test.not("abc" < XEQ) %>
* Expect `TRUE` if `R.__vs__(L)` returns a positive number (R > L)  <% test("abc" < XGT) %>
* Expect `TRUE` if `R.__vs__(L)` doesn't return a number            <% test("abc" < XNN) %>


### When L is a function
By default functions are less than lists and namespaces and greater than
`NOTHING`, numbers and strings. In case also `R` is a string, the two function
bodies are compared.
* Expect `FALSE` wher R is `NOTHING`                                <% test.not(foo1<NOTHING) %> 
* Expect `FALSE` when R is a number                                 <% test.not(foo1<10) %> 
* Expect `FALSE` when R is a string                                 <% test.not(foo1<"abc") %> 
* Expect `FALSE` when R is a function with the same body as L       <% test.not(foo1 < foo1) %> 
* Expect `FALSE` when R is a function with body less than L's       <% test.not(foo2 < foo1) %> 
* Expect `TRUE` when R is a function with body greater than L's     <% test(foo1 < foo2) %> 
* Expect `TRUE` when R is a list                                    <% test(foo1<[10,20,30]) %> 
* Expect `TRUE` when R is a namespace                               <% test(foo1<{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `<` operation is defined by its return value.
* Expect `FALSE` if `R.__vs__(L)` returns a negative number (R < L) <% test.not(foo1 < XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                <% test.not(foo1 < XEQ) %>
* Expect `TRUE` if `R.__vs__(L)` returns a positive number (R > L)  <% test(foo1 < XGT) %>
* Expect `TRUE` if `R.__vs__(L)` doesn't return a number            <% test(foo1 < XNN) %>


### When L is a list
By default lists are less than namespace and greater than `NOTHING`, numbers,
text and functions. Two lists compare item by item; the first non-equal item
determines if the lists is less-that or greater than each-other. This is the same
principle of the alphabetic ordering used for text.
* Expect `FALSE` wher R is `NOTHING`        <% test.not([10,20,30]<NOTHING) %> 
* Expect `FALSE` when R is a number         <% test.not([10,20,30]<10) %> 
* Expect `FALSE` when R is a string         <% test.not([10,20,30]<"abc") %> 
* Expect `FALSE` when R is a function       <% test.not([10,20,30]<foo1) %> 
* Expect `FALSE` when R is the same list    <% test.not([10,20,30]<[10,20,30]) %> 
* Expect `FALSE` when R is a list and the first non-equal item of R is less than the corresponding item of L    <% test.not([10,20,30]<[10,15,30]) %> 
* Expect `TRUE` when R is a list and the first non-equal item of R is greater than the corresponding item of L  <% test([10,20,30]<[10,25,30]) %> 
* Expect `TRUE` when R is a namespace       <% test([10,20,30]<{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `<` operation is defined by its return value.
* Expect `FALSE` if `R.__vs__(L)` returns a negative number (R < L) <% test.not([1,2,3] < XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                <% test.not([1,2,3] < XEQ) %>
* Expect `TRUE` if `R.__vs__(L)` returns a positive number (R > L)  <% test([1,2,3] < XGT) %>
* Expect `TRUE` if `R.__vs__(L)` doesn't return a number            <% test([1,2,3] < XNN) %>


### When L is a namespace
By default lists are greater than any other data type. Two namespaces compare item 
by item; the first non-equal item determines if the namespace is less-that or 
greater than each-other. This is the same principle of the alphabetic ordering 
used for text. 
* Expect `FALSE` wher R is `NOTHING`                            <% test.not({a=10, b=20, c=30}<NOTHING) %> 
* Expect `FALSE` when R is a number                             <% test.not({a=1,b=2,c=3}<10) %> 
* Expect `FALSE` when R is a string                             <% test.not({a=1,b=2,c=3}<"abc") %> 
* Expect `FALSE` when R is a function                           <% test.not({a=1,b=2,c=3}<foo1) %> 
* Expect `FALSE` when R is a list                               <% test.not({a=1,b=2,c=3}<[1,2,3]) %> 
* Expect `FALSE` when R is a namespace and the first non-equal item of R is less than the corresponding item of L    <% test.not({a=10,b=20,c=30}<{a=10,b=15,c=30}) %> 
* Expect `TRUE` when R is a namespace and the first non-equal item of R is greater than the corresponding item of L  <% test({a=10,b=20,c=30}<{a=10,b=25,c=30}) %> 

If `L` containis the trigger function `__vs__`, the result of the `<` operation 
is defined by its return value.
* Expect `TRUE` when R is `NOTHING` and `L.__vs__(R)` returns a negative number     <% test(XLT < NOTHING) %> 
* Expect `TRUE` when R is a number and `L.__vs__(R)` returns a negative number      <% test(XLT < 10) %> 
* Expect `TRUE` when R is a string and `L.__vs__(R)` returns a negative number      <% test(XLT < "abc") %> 
* Expect `TRUE` when R is a function and `L.__vs__(R)` returns a negative number    <% test(XLT < foo1) %> 
* Expect `TRUE` when R is a list and `L.__vs__(R)` returns a negative number        <% test(XLT < [1,2,3]) %> 
* Expect `TRUE` when R is a namespace and `L.__vs__(R)` returns a negative number   <% test(XLT < {}) %> 
* Expect `FALSE` when R is `NOTHING` and `L.__vs__(R)` returns 0    <% test.not(XEQ < NOTHING) %> 
* Expect `FALSE` when R is a number and `L.__vs__(R)` returns 0     <% test.not(XEQ < 10) %> 
* Expect `FALSE` when R is a string and `L.__vs__(R)` returns 0     <% test.not(XEQ < "abc") %> 
* Expect `FALSE` when R is a function and `L.__vs__(R)` returns 0   <% test.not(XEQ < foo1) %> 
* Expect `FALSE` when R is a list and `L.__vs__(R)` returns 0       <% test.not(XEQ < [1,2,3]) %> 
* Expect `FALSE` when R is a namespace and `L.__vs__(R)` returns 0  <% test.not(XEQ < {a=10, b=20, c=30}) %> 
* Expect `FALSE` when R is `NOTHING` and `L.__vs__(R)` returns a positive number    <% test.not(XGT < NOTHING) %> 
* Expect `FALSE` when R is a number and `L.__vs__(R)` returns a positive number     <% test.not(XGT < 10) %> 
* Expect `FALSE` when R is a string and `L.__vs__(R)` returns a positive number     <% test.not(XGT < "abc") %> 
* Expect `FALSE` when R is a function and `L.__vs__(R)` returns a positive number   <% test.not(XGT < foo1) %> 
* Expect `FALSE` when R is a list and `L.__vs__(R)` returns a positive number       <% test.not(XGT < [1,2,3]) %> 
* Expect `FALSE` when R is a namespace and `L.__vs__(R)` returns a positive number  <% test.not(XGT < {a=10, b=20, c=30}) %> 
* Expect fallback to the default behaviour when R is `NOTHING` and `L.__vs__(R)` doesn't return a number    <% test.not(XNN < NOTHING) %> 
* Expect fallback to the default behaviour when R is a number and `L.__vs__(R)` doesn't return a number     <% test.not(XNN < 10) %> 
* Expect fallback to the default behaviour when R is a string and `L.__vs__(R)` doesn't return a number     <% test.not(XNN < "abc") %> 
* Expect fallback to the default behaviour when R is a function and `L.__vs__(R)` doesn't return a number   <% test.not(XNN < foo1) %> 
* Expect fallback to the default behaviour when R is a list and `L.__vs__(R)` doesn't return a number       <% test.not(XNN < [1,2,3]) %> 


If `R` is a namespace containing the trigger function `__vs__`, the result of
the `<` operation is defined by its return value.
* Expect `FALSE` if `R.__vs__(L)` returns a negative number (R < L) <% test.not({a=1,b=2,c=3} < XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                <% test.not({a=1,b=2,c=3} < XEQ) %>
* Expect `TRUE` if `R.__vs__(L)` returns a positive number (R > L)  <% test({a=1,b=2,c=3} < XGT) %>
* It should fallback to the default behaviour if `R.__vs__(L)` doesn't return a number  <% test.not({a=1,b=2,c=3} < XNN) %>
