<%  title = "olowiki expression: L > R"  %>
<%  __render__ = import("/bin/markdown")  %>

<% test = import("/bin/test") %>
<% check = test.check %>

<% XLT = {__vs__: (R) -> -100} %>
<% XEQ = {__vs__: (R) -> 0} %>
<% XGT = {__vs__: (R) -> +35} %>
<% XNN = {__vs__: (R) -> "abc"} %>
<% foo1: () -> 1+1 %>
<% foo2: () -> 1+2 %>


### When L is NOTHING
By default `NOTHING` is equal only to itself and less than any other data type.
* Expect `NOTHING > NOTHING` to be `FALSE`   <% test.not(NOTHING>NOTHING) %>
* Expect `NOTHING > number` to be `FALSE`    <% test.not(NOTHING>10) %>
* Expect `NOTHING > text` to be `FALSE`      <% test.not(NOTHING>"abc") %>
* Expect `NOTHING > function` to be `FALSE`  <% test.not(NOTHING>foo1) %>
* Expect `NOTHING > list` to be `FALSE`      <% test.not(NOTHING>[10,20,30]) %>
* Expect `NOTHING > namespace` to be `FALSE` <% test.not(NOTHING>{}) %>

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `>` operation is defined by its return value.
* Expect `TRUE` if `R.__vs__(L)` returns a negative number (R < L) <% test(NOTHING > XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                 <% test.not(NOTHING > XEQ) %>
* Expect `FALSE` if `R.__vs__(L)` returns a positive number (R > L)  <% test.not(NOTHING > XGT) %>
* Expect `FALSE` if `R.__vs__(L)` doesn't return a number            <% test.not(NOTHING > XNN) %>


### When L is a number
By default a number is lower than bigger numbers, text, functions, lists and
namespaces.
* Expect `TRUE` when R is `NOTHING`        <% test(10>NOTHING) %> 
* Expect `TRUE` if R is a smaller number   <% test(10>5) %> 
* Expect `FALSE` if R is the same number     <% test.not(10>10) %> 
* Expect `FALSE` if R is a bigger number     <% test.not(10>20) %> 
* Expect `FALSE` when R is a string          <% test.not(10>"abc") %> 
* Expect `FALSE` if R is a function          <% test.not(10>foo1) %> 
* Expect `FALSE` when R is a list            <% test.not(10>[10,20,30]) %> 
* Expect `FALSE` when R is a namespace       <% test.not(10>{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `>` operation is defined by its return value.
* Expect `TRUE` if `R.__vs__(L)` returns a negative number (R < L) <% test(10 > XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                 <% test.not(10 > XEQ) %>
* Expect `FALSE` if `R.__vs__(L)` returns a positive number (R > L)  <% test.not(10 > XGT) %>
* Expect `FALSE` if `R.__vs__(L)` doesn't return a number            <% test.not(10 > XNN) %>


### When L is a string
By default a text is equal only to the same text.
* Expect `TRUE` wher R is `NOTHING`            <% test("abc">NOTHING) %>
* Expect `TRUE` when R is a number             <% test("abc">10) %> 
* Expect `TRUE` when R is a string that comes before L alphabetically   <% test("abc">"aaa") %> 
* Expect `FALSE` when R is the same string       <% test.not("abc">"abc") %> 
* Expect `FALSE` when R is a string that comes after L alphabetically   <% test.not("abc">"def") %> 
* Expect `FALSE` if R is a function             <% test.not("abc">foo1) %> 
* Expect `FALSE` when R is a list               <% test.not("abc">[10,20,30]) %> 
* Expect `FALSE` when R is a namespace          <% test.not("abc">{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `>` operation is defined by its return value.
* Expect `TRUE` if `R.__vs__(L)` returns a negative number (R < L) <% test("abc" > XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                 <% test.not("abc" > XEQ) %>
* Expect `FALSE` if `R.__vs__(L)` returns a positive number (R > L)  <% test.not("abc" > XGT) %>
* Expect `FALSE` if `R.__vs__(L)` doesn't return a number            <% test.not("abc" > XNN) %>


### When L is a function
By default functions are less than lists and namespaces and greater than
`NOTHING`, numbers and strings. In case also `R` is a string, the two function
bodies are compared.
* Expect `TRUE` wher R is `NOTHING`                                <% test(foo1>NOTHING) %> 
* Expect `TRUE` when R is a number                                 <% test(foo1>10) %> 
* Expect `TRUE` when R is a string                                 <% test(foo1>"abc") %> 
* Expect `TRUE` when R is a function with body less than L's       <% test(foo2 > foo1) %> 
* Expect `FALSE` when R is a function with the same body as L        <% test.not(foo1 > foo1) %> 
* Expect `FALSE` when R is a function with body greater than L's     <% test.not(foo1 > foo2) %> 
* Expect `FALSE` when R is a list                                    <% test.not(foo1>[10,20,30]) %> 
* Expect `FALSE` when R is a namespace                               <% test.not(foo1>{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `>` operation is defined by its return value.
* Expect `TRUE` if `R.__vs__(L)` returns a negative number (R < L) <% test(foo1 > XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                 <% test.not(foo1 > XEQ) %>
* Expect `FALSE` if `R.__vs__(L)` returns a positive number (R > L)  <% test.not(foo1 > XGT) %>
* Expect `FALSE` if `R.__vs__(L)` doesn't return a number            <% test.not(foo1 > XNN) %>


### When L is a list
By default lists are less than namespace and greater than `NOTHING`, numbers,
text and functions. Two lists compare item by item; the first non-equal item
determines if the lists is less-that or greater than each-other. This is the same
principle of the alphabetic ordering used for text.
* Expect `TRUE` wher R is `NOTHING`        <% test([10,20,30]>NOTHING) %> 
* Expect `TRUE` when R is a number         <% test([10,20,30]>10) %> 
* Expect `TRUE` when R is a string         <% test([10,20,30]>"abc") %> 
* Expect `TRUE` when R is a function       <% test([10,20,30]>foo1) %> 
* Expect `FALSE` when R is the same list     <% test.not([10,20,30]>[10,20,30]) %> 
* Expect `TRUE` when R is a list and the first non-equal item of R is less than the corresponding item of L    <% test([10,20,30]>[10,15,30]) %> 
* Expect `FALSE` when R is a list and the first non-equal item of R is greater than the corresponding item of L  <% test.not([10,20,30]>[10,25,30]) %> 
* Expect `FALSE` when R is a namespace       <% test.not([10,20,30]>{}) %> 

If `R` is a namespace containing the trigger function `__vs__`, the result of
the `>` operation is defined by its return value.
* Expect `TRUE` if `R.__vs__(L)` returns a negative number (R < L) <% test([1,2,3] > XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                 <% test.not([1,2,3] > XEQ) %>
* Expect `FALSE` if `R.__vs__(L)` returns a positive number (R > L)  <% test.not([1,2,3] > XGT) %>
* Expect `FALSE` if `R.__vs__(L)` doesn't return a number            <% test.not([1,2,3] > XNN) %>


### When L is a namespace
By default lists are greater than any other data type. Two namespaces compare item 
by item; the first non-equal item determines if the namespace is less-that or 
greater than each-other. This is the same principle of the alphabetic ordering 
used for text. 
* Expect `TRUE` wher R is `NOTHING`                            <% test({a=10, b=20, c=30}>NOTHING) %> 
* Expect `TRUE` when R is a number                             <% test({a=1,b=2,c=3}>10) %> 
* Expect `TRUE` when R is a string                             <% test({a=1,b=2,c=3}>"abc") %> 
* Expect `TRUE` when R is a function                           <% test({a=1,b=2,c=3}>foo1) %> 
* Expect `TRUE` when R is a list                               <% test({a=1,b=2,c=3}>[1,2,3]) %> 
* Expect `TRUE` when R is a namespace and the first non-equal item of R is less than the corresponding item of L    <% test({a=10,b=20,c=30}>{a=10,b=15,c=30}) %> 
* Expect `FALSE` when R is a namespace with the same content                                                          <% test.not({a=1,b=2,c=3}>{a=1,b=2,c=3}) %> 
* Expect `FALSE` when R is a namespace and the first non-equal item of R is greater than the corresponding item of L  <% test.not({a=10,b=20,c=30}>{a=10,b=25,c=30}) %> 

If `L` containis the trigger function `__vs__`, the result of the `>` operation 
is defined by its return value.
* Expect `FALSE` when R is `NOTHING` and `L.__vs__(R)` returns a negative number     <% test.not(XLT > NOTHING) %> 
* Expect `FALSE` when R is a number and `L.__vs__(R)` returns a negative number      <% test.not(XLT > 10) %> 
* Expect `FALSE` when R is a string and `L.__vs__(R)` returns a negative number      <% test.not(XLT > "abc") %> 
* Expect `FALSE` when R is a function and `L.__vs__(R)` returns a negative number    <% test.not(XLT > foo1) %> 
* Expect `FALSE` when R is a list and `L.__vs__(R)` returns a negative number        <% test.not(XLT > [1,2,3]) %> 
* Expect `FALSE` when R is a namespace and `L.__vs__(R)` returns a negative number   <% test.not(XLT > {}) %> 
* Expect `FALSE` when R is `NOTHING` and `L.__vs__(R)` returns 0    <% test.not(XEQ > NOTHING) %> 
* Expect `FALSE` when R is a number and `L.__vs__(R)` returns 0     <% test.not(XEQ > 10) %> 
* Expect `FALSE` when R is a string and `L.__vs__(R)` returns 0     <% test.not(XEQ > "abc") %> 
* Expect `FALSE` when R is a function and `L.__vs__(R)` returns 0   <% test.not(XEQ > foo1) %> 
* Expect `FALSE` when R is a list and `L.__vs__(R)` returns 0       <% test.not(XEQ > [1,2,3]) %> 
* Expect `FALSE` when R is a namespace and `L.__vs__(R)` returns 0  <% test.not(XEQ > {a=10, b=20, c=30}) %> 
* Expect `TRUE` when R is `NOTHING` and `L.__vs__(R)` returns a positive number    <% test(XGT > NOTHING) %> 
* Expect `TRUE` when R is a number and `L.__vs__(R)` returns a positive number     <% test(XGT > 10) %> 
* Expect `TRUE` when R is a string and `L.__vs__(R)` returns a positive number     <% test(XGT > "abc") %> 
* Expect `TRUE` when R is a function and `L.__vs__(R)` returns a positive number   <% test(XGT > foo1) %> 
* Expect `TRUE` when R is a list and `L.__vs__(R)` returns a positive number       <% test(XGT > [1,2,3]) %> 
* Expect `TRUE` when R is a namespace and `L.__vs__(R)` returns a positive number  <% test(XGT > {a=10, b=20, c=30}) %> 
* Expect fallback to the default behaviour when R is `NOTHING` and `L.__vs__(R)` doesn't return a number    <% test(XNN > NOTHING) %> 
* Expect fallback to the default behaviour when R is a number and `L.__vs__(R)` doesn't return a number     <% test(XNN > 10) %> 
* Expect fallback to the default behaviour when R is a string and `L.__vs__(R)` doesn't return a number     <% test(XNN > "abc") %> 
* Expect fallback to the default behaviour when R is a function and `L.__vs__(R)` doesn't return a number   <% test(XNN > foo1) %> 
* Expect fallback to the default behaviour when R is a list and `L.__vs__(R)` doesn't return a number       <% test(XNN > [1,2,3]) %> 


If `R` is a namespace containing the trigger function `__vs__`, the result of
the `>` operation is defined by its return value.
* Expect `TRUE` if `R.__vs__(L)` returns a negative number (R < L) <% test({a=1,b=2,c=3} > XLT) %>
* Expect `FALSE` if `R.__vs__(L)` returns 0 (R == L)                 <% test.not({a=1,b=2,c=3} > XEQ) %>
* Expect `FALSE` if `R.__vs__(L)` returns a positive number (R > L)  <% test.not({a=1,b=2,c=3} > XGT) %>
* It should fallback to the default behaviour if `R.__vs__(L)` doesn't return a number  <% test({a=1,b=2,c=3} > XNN) %>
